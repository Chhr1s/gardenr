---
title: "intro-gardenr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro-gardenr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{gardenr, tidyverse, glmertree}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Example

Here is an example of using `cross_validate_it()` to help with hyperparameter tuning. 

```{r setup, message=FALSE, warning=FALSE}
#devtools::install_github("Chhr1s/gardenr")
library(gardenr)
library(glmertree)
library(tidyverse)
```

## Simulate some data

Here's a function within the package to simulate some multilevel data. It has defaults, but these can be changed. use `?sim_multilevel()` for details.

```{r}
dat <- sim_multilevel()
```

## Split Data & Make CV Object

Wherever possible, I wanted to rely on good functions from the `{tidymodels}` framework. We can use `{rsample}` to spit the data and make a cross-validation object. 

```{r}
example_split <- rsample::initial_split(dat)
example_train <- rsample::training(example_split)
example_test  <-  rsample::testing(example_split)
cv <- rsample::vfold_cv(data = example_train, v = 10)
```

## Make a `Formula` object

This is the proposed GLMM tree formula. This is *not* a normal `formula` object, but a `Formula` object instead. See `?Formula::as.Formula` for an explanation of the differences.

```{r}
ex_formula <-
   Formula::as.Formula(
      'outcome ~ small_1 |
      (1 | id_vector) |
      small_2 + small_c_1 + small_c_2 + nuisance_1a + nuisance_c_1a'
      )

```

## Make a Tuning Grid

We can then use dials to make a tuning grid. Notice that the parameter objects for GLMM trees have already been made and are in `{gardenr}` (e.g., `alpha_par()`)

```{r}
tuning_grid <-
  dials::grid_max_entropy(
    maxdepth_par(maxdepth_min = 2L, maxdepth_max = 20L),
    alpha_par(alpha_min = 0.10, alpha_max = 0.001),
    trim_par(trim_min = 0.01, trim_max = 0.5),
    size = 10
  )
tuning_grid
```

## Fit the Model to the Cross-Validated Data

Here we fit the model to the cross-validated object.

```{r message=FALSE}
fitted <-
   cross_validate_it(
      cv_obj = cv,
      seed = 713,
      tuning_grid = tuning_grid,
      mod_formula = ex_formula, 
      cluster = id_vector
      )
```

## See Best Fitting Hyperparameters

```{r}
best_fit <- 
  fitted %>% 
  arrange(mean_rmse) 
best_fit
```

```{r}
best_fit_trained <- 
  lmertree(
    data = example_train, 
    formula = 
      ex_formula, 
    maxdepth = best_fit$maxdepth_par[1], 
    alpha = best_fit$alpha_par[1],
    trim = best_fit$trim_par[1], 
    cluster = id_vector,
    verbose = TRUE
  )
```

## See the Default Plot

```{r}
plot(best_fit_trained$tree)
```

## Get RMSE for unseen data

```{r}
example_test %>% 
  mutate(
    predictions =
      predict(
        best_fit_trained, 
        newdata = example_test, 
        allow.new.levels = TRUE
        )
    ) %>% 
  summarize(
    rmse_unseen = 
      rmse(observed_y = outcome, predicted_y = predictions)
    )

```

## Plot the Parameters in One Space

This can clarify what the difference is

```{r}
summary(best_fit_trained$tree) %>%
  purrr::map_dfr(broom::tidy, .id = 'node') %>%
  mutate(node = factor(node)) %>%
  ggplot(
    aes(
      x = term,
      y = estimate,
      color = node,
      ymin = estimate - 1.96*std.error,
      ymax = estimate + 1.96*std.error
      )
    ) +
  geom_pointrange(position = position_dodge(width = 0.5)) +
  theme_bw()
```

